{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/GoIT/Projects/dz/next/next-module-3-4/node_modules/%40tanstack/query-core/src/mutationObserver.ts"],"sourcesContent":["import { getDefaultState } from './mutation'\nimport { notifyManager } from './notifyManager'\nimport { Subscribable } from './subscribable'\nimport { hashKey, shallowEqualObjects } from './utils'\nimport type { QueryClient } from './queryClient'\nimport type {\n  DefaultError,\n  MutateOptions,\n  MutationFunctionContext,\n  MutationObserverOptions,\n  MutationObserverResult,\n} from './types'\nimport type { Action, Mutation } from './mutation'\n\n// TYPES\n\ntype MutationObserverListener<TData, TError, TVariables, TOnMutateResult> = (\n  result: MutationObserverResult<TData, TError, TVariables, TOnMutateResult>,\n) => void\n\n// CLASS\n\nexport class MutationObserver<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TOnMutateResult = unknown,\n> extends Subscribable<\n  MutationObserverListener<TData, TError, TVariables, TOnMutateResult>\n> {\n  options!: MutationObserverOptions<TData, TError, TVariables, TOnMutateResult>\n\n  #client: QueryClient\n  #currentResult: MutationObserverResult<\n    TData,\n    TError,\n    TVariables,\n    TOnMutateResult\n  > = undefined!\n  #currentMutation?: Mutation<TData, TError, TVariables, TOnMutateResult>\n  #mutateOptions?: MutateOptions<TData, TError, TVariables, TOnMutateResult>\n\n  constructor(\n    client: QueryClient,\n    options: MutationObserverOptions<\n      TData,\n      TError,\n      TVariables,\n      TOnMutateResult\n    >,\n  ) {\n    super()\n\n    this.#client = client\n    this.setOptions(options)\n    this.bindMethods()\n    this.#updateResult()\n  }\n\n  protected bindMethods(): void {\n    this.mutate = this.mutate.bind(this)\n    this.reset = this.reset.bind(this)\n  }\n\n  setOptions(\n    options: MutationObserverOptions<\n      TData,\n      TError,\n      TVariables,\n      TOnMutateResult\n    >,\n  ) {\n    const prevOptions = this.options as\n      | MutationObserverOptions<TData, TError, TVariables, TOnMutateResult>\n      | undefined\n    this.options = this.#client.defaultMutationOptions(options)\n    if (!shallowEqualObjects(this.options, prevOptions)) {\n      this.#client.getMutationCache().notify({\n        type: 'observerOptionsUpdated',\n        mutation: this.#currentMutation,\n        observer: this,\n      })\n    }\n\n    if (\n      prevOptions?.mutationKey &&\n      this.options.mutationKey &&\n      hashKey(prevOptions.mutationKey) !== hashKey(this.options.mutationKey)\n    ) {\n      this.reset()\n    } else if (this.#currentMutation?.state.status === 'pending') {\n      this.#currentMutation.setOptions(this.options)\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.hasListeners()) {\n      this.#currentMutation?.removeObserver(this)\n    }\n  }\n\n  onMutationUpdate(\n    action: Action<TData, TError, TVariables, TOnMutateResult>,\n  ): void {\n    this.#updateResult()\n\n    this.#notify(action)\n  }\n\n  getCurrentResult(): MutationObserverResult<\n    TData,\n    TError,\n    TVariables,\n    TOnMutateResult\n  > {\n    return this.#currentResult\n  }\n\n  reset(): void {\n    // reset needs to remove the observer from the mutation because there is no way to \"get it back\"\n    // another mutate call will yield a new mutation!\n    this.#currentMutation?.removeObserver(this)\n    this.#currentMutation = undefined\n    this.#updateResult()\n    this.#notify()\n  }\n\n  mutate(\n    variables: TVariables,\n    options?: MutateOptions<TData, TError, TVariables, TOnMutateResult>,\n  ): Promise<TData> {\n    this.#mutateOptions = options\n\n    this.#currentMutation?.removeObserver(this)\n\n    this.#currentMutation = this.#client\n      .getMutationCache()\n      .build(this.#client, this.options)\n\n    this.#currentMutation.addObserver(this)\n\n    return this.#currentMutation.execute(variables)\n  }\n\n  #updateResult(): void {\n    const state =\n      this.#currentMutation?.state ??\n      getDefaultState<TData, TError, TVariables, TOnMutateResult>()\n\n    this.#currentResult = {\n      ...state,\n      isPending: state.status === 'pending',\n      isSuccess: state.status === 'success',\n      isError: state.status === 'error',\n      isIdle: state.status === 'idle',\n      mutate: this.mutate,\n      reset: this.reset,\n    } as MutationObserverResult<TData, TError, TVariables, TOnMutateResult>\n  }\n\n  #notify(action?: Action<TData, TError, TVariables, TOnMutateResult>): void {\n    notifyManager.batch(() => {\n      // First trigger the mutate callbacks\n      if (this.#mutateOptions && this.hasListeners()) {\n        const variables = this.#currentResult.variables!\n        const onMutateResult = this.#currentResult.context\n\n        const context = {\n          client: this.#client,\n          meta: this.options.meta,\n          mutationKey: this.options.mutationKey,\n        } satisfies MutationFunctionContext\n\n        if (action?.type === 'success') {\n          this.#mutateOptions.onSuccess?.(\n            action.data,\n            variables,\n            onMutateResult,\n            context,\n          )\n          this.#mutateOptions.onSettled?.(\n            action.data,\n            null,\n            variables,\n            onMutateResult,\n            context,\n          )\n        } else if (action?.type === 'error') {\n          this.#mutateOptions.onError?.(\n            action.error,\n            variables,\n            onMutateResult,\n            context,\n          )\n          this.#mutateOptions.onSettled?.(\n            undefined,\n            action.error,\n            variables,\n            onMutateResult,\n            context,\n          )\n        }\n      }\n\n      // Then trigger the listeners\n      this.listeners.forEach((listener) => {\n        listener(this.#currentResult)\n      })\n    })\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 143, "column": 0}, "map": {"version":3,"sources":["file:///C:/GoIT/Projects/dz/next/next-module-3-4/node_modules/%40tanstack/react-query/src/useMutation.ts"],"sourcesContent":["'use client'\nimport * as React from 'react'\nimport {\n  MutationObserver,\n  noop,\n  notifyManager,\n  shouldThrowError,\n} from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport type {\n  UseMutateFunction,\n  UseMutationOptions,\n  UseMutationResult,\n} from './types'\nimport type { DefaultError, QueryClient } from '@tanstack/query-core'\n\n// HOOK\n\nexport function useMutation<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TOnMutateResult = unknown,\n>(\n  options: UseMutationOptions<TData, TError, TVariables, TOnMutateResult>,\n  queryClient?: QueryClient,\n): UseMutationResult<TData, TError, TVariables, TOnMutateResult> {\n  const client = useQueryClient(queryClient)\n\n  const [observer] = React.useState(\n    () =>\n      new MutationObserver<TData, TError, TVariables, TOnMutateResult>(\n        client,\n        options,\n      ),\n  )\n\n  React.useEffect(() => {\n    observer.setOptions(options)\n  }, [observer, options])\n\n  const result = React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  const mutate = React.useCallback<\n    UseMutateFunction<TData, TError, TVariables, TOnMutateResult>\n  >(\n    (variables, mutateOptions) => {\n      observer.mutate(variables, mutateOptions).catch(noop)\n    },\n    [observer],\n  )\n\n  if (\n    result.error &&\n    shouldThrowError(observer.options.throwOnError, [result.error])\n  ) {\n    throw result.error\n  }\n\n  return { ...result, mutate, mutateAsync: result.mutate }\n}\n"],"names":[],"mappings":";;;;;AACA,YAAY,WAAW;;;AACvB;AAMA,SAAS,sBAAsB;;;;;AAUxB,SAAS,YAMd,OAAA,EACA,WAAA,EAC+D;IAC/D,MAAM,aAAS,2MAAA,EAAe,WAAW;IAEzC,MAAM,CAAC,QAAQ,CAAA,GAAU,yKAAA;gCACvB,IACE,IAAI,yMAAA,CACF,QACA;;IAIA,0KAAA;iCAAU,MAAM;YACpB,SAAS,UAAA,CAAW,OAAO;QAC7B;gCAAG;QAAC;QAAU,OAAO;KAAC;IAEtB,MAAM,SAAe,qLAAA,CACb,4KAAA;oDACJ,CAAC,gBACC,SAAS,SAAA,CAAU,mMAAA,CAAc,UAAA,CAAW,aAAa,CAAC;mDAC5D;QAAC,QAAQ;KAAA;oDAEX,IAAM,SAAS,gBAAA,CAAiB;;oDAChC,IAAM,SAAS,gBAAA,CAAiB;;IAGlC,MAAM,SAAe,4KAAA;2CAGnB,CAAC,WAAW,kBAAkB;YAC5B,SAAS,MAAA,CAAO,WAAW,aAAa,EAAE,KAAA,CAAM,kLAAI;QACtD;0CACA;QAAC,QAAQ;KAAA;IAGX,IACE,OAAO,KAAA,QACP,8LAAA,EAAiB,SAAS,OAAA,CAAQ,YAAA,EAAc;QAAC,OAAO,KAAK;KAAC,GAC9D;QACA,MAAM,OAAO,KAAA;IACf;IAEA,OAAO;QAAE,GAAG,MAAA;QAAQ;QAAQ,aAAa,OAAO,MAAA;IAAO;AACzD","debugId":null}}]
}